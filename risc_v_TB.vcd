$date
	Fri Aug  9 01:10:23 2024
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module risc_v_TB $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # zero $end
$var wire 32 $ writeData [31:0] $end
$var wire 1 % regWrite $end
$var wire 32 & readData2 [31:0] $end
$var wire 32 ' readData1 [31:0] $end
$var wire 32 ( nextPC [31:0] $end
$var wire 1 ) memWrite $end
$var wire 32 * memData [31:0] $end
$var wire 1 + jump $end
$var wire 32 , instruction [31:0] $end
$var wire 32 - immGen [31:0] $end
$var wire 32 . currentPC [31:0] $end
$var wire 1 / branch $end
$var wire 1 0 aluSrc $end
$var wire 32 1 aluResult [31:0] $end
$var wire 4 2 aluControl [3:0] $end
$scope module alu $end
$var wire 32 3 srcB [31:0] $end
$var wire 1 # zero $end
$var wire 32 4 srcA [31:0] $end
$var wire 4 5 aluControl [3:0] $end
$var reg 32 6 aluResult [31:0] $end
$upscope $end
$scope module control $end
$var wire 3 7 funct3 [2:0] $end
$var wire 7 8 funct7 [6:0] $end
$var wire 7 9 opcode [6:0] $end
$var reg 4 : aluControl [3:0] $end
$var reg 1 0 aluSrc $end
$var reg 1 / branch $end
$var reg 1 + jump $end
$var reg 1 ) memWrite $end
$var reg 1 % regWrite $end
$upscope $end
$scope module dmem $end
$var wire 32 ; address [31:0] $end
$var wire 1 ! clk $end
$var wire 1 ) memWrite $end
$var wire 32 < writeData [31:0] $end
$var reg 32 = readData [31:0] $end
$upscope $end
$scope module imem $end
$var wire 32 > address [31:0] $end
$var reg 32 ? instruction [31:0] $end
$upscope $end
$scope module immgen $end
$var wire 32 @ instruction [31:0] $end
$var reg 32 A immOut [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 32 B nextPC [31:0] $end
$var wire 1 " reset $end
$var reg 32 C currentPC [31:0] $end
$upscope $end
$scope module regfile $end
$var wire 1 ! clk $end
$var wire 5 D rd [4:0] $end
$var wire 32 E readData1 [31:0] $end
$var wire 32 F readData2 [31:0] $end
$var wire 1 % regWrite $end
$var wire 5 G rs1 [4:0] $end
$var wire 5 H rs2 [4:0] $end
$var wire 32 I writeData [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx I
b1 H
b0 G
bx F
bx E
b11 D
b0 C
b100 B
b1 A
b100000000000110010011 @
b100000000000110010011 ?
b0 >
bx =
bx <
bx ;
b0 :
b10011 9
b0 8
b0 7
bx 6
b0 5
bx 4
b1 3
b0 2
bx 1
10
0/
b0 .
b1 -
b100000000000110010011 ,
0+
bx *
0)
b100 (
bx '
bx &
1%
bx $
x#
1"
0!
$end
#50
0"
#100
bx 3
00
1%
b0 -
b0 A
b110011 9
b100 D
b10 H
b1 G
b1000001000001000110011 ,
b1000001000001000110011 ?
b1000001000001000110011 @
b1000 (
b1000 B
b100 .
b100 >
b100 C
1!
#150
0!
#200
0%
bx 8
bx 7
bx 9
bx D
bx H
bx G
bx ,
bx ?
bx @
b1100 (
b1100 B
b1000 .
b1000 >
b1000 C
1!
#250
0!
#300
b10000 (
b10000 B
b1100 .
b1100 >
b1100 C
1!
#350
0!
#400
b10100 (
b10100 B
b10000 .
b10000 >
b10000 C
1!
#450
0!
#500
b11000 (
b11000 B
b10100 .
b10100 >
b10100 C
1!
#550
0!
#600
b11100 (
b11100 B
b11000 .
b11000 >
b11000 C
1!
#650
0!
#700
b100000 (
b100000 B
b11100 .
b11100 >
b11100 C
1!
#750
0!
#800
b100100 (
b100100 B
b100000 .
b100000 >
b100000 C
1!
#850
0!
#900
b101000 (
b101000 B
b100100 .
b100100 >
b100100 C
1!
#950
0!
#1000
b101100 (
b101100 B
b101000 .
b101000 >
b101000 C
1!
